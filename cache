#include <iostream>
#include <sstream>
#include <string>
#include <fstream>
#include <bitset>
#include <math.h>
#include <algorithm>
using namespace std;

void simulationOne() { // 256 byte cache, 32 byte block, direct mapped
    // Text File Initializations
    stringstream ss;
    ifstream inFile;
    inFile.open("addresses.txt");
    string line, addy;
    // Cache parameter declarations
    int numOfSets = 256 / 32;                   // 8
    int offsetBits = log2(32);                  // 5
    int indexBits = log2(numOfSets);            // 3
    int tagBits = 12 - offsetBits - indexBits;  // 4
    int lookupTime = ceil(log2(numOfSets)) * 1; // 1 way associativity
    int costOfCacheMiss = lookupTime + 100;
    int i, indexVal;
    int currTick = 0;
    unsigned x;
    double hitRate, missRate = 0;
    
    // Cache data structure initialization
    string cache[3][8];
    // Index bits
    cache[0][0] = "000";
    cache[0][1] = "001";
    cache[0][2] = "010";
    cache[0][3] = "011";
    cache[0][4] = "100";
    cache[0][5] = "101";
    cache[0][6] = "110";
    cache[0][7] = "111";
    
    // Valid Bits
    for (i = 0; i < numOfSets; i++){
        cache[1][i] = "0";      // Cache is empty at start
    }

    // Tag Bits
    while(getline(inFile, line)) {
        ss << hex << line;              // stores the hex value of line in ss
        ss >> x;                        // converts to decimal
        bitset<12> b(x);                // converts to binary
        addy = b.to_string();           // converts to string

        string tag = addy.substr(0, 4);
        string index = addy.substr(4,3);
        string offset = addy.substr(7,5);

        // Find index of input
        for (i = 0; i < numOfSets; i++){
            if (cache[0][i] == index) {
                indexVal = i;       // find the correct column for the index
                break;
            }
        }
        
        // *************************************************************************
        // Checks to see if cache tag is empty
        // Determines cache hit/miss
        // If miss, it fills the tag with the input
        // *************************************************************************

        if (cache[1][indexVal] == "0") {        // if cache is empty
            cache[1][indexVal] = "1";
            cache[2][indexVal] = tag;
            currTick += costOfCacheMiss;
            missRate += 1;
        }
        else {                                  // if cache is NOT empty
            if (cache[2][indexVal] == tag) {    // cache hit
                currTick += 5;
                hitRate += 1;
            }
            else {                              // cache miss
                cache[2][indexVal] = tag;
                currTick += costOfCacheMiss;
                missRate += 1;
            }
        }
        ss.clear();     // clear string stream
    }
    
    hitRate = hitRate / (hitRate + missRate);
    missRate = 1 - hitRate;
    // converts to percentage
    hitRate *= 100; 
    missRate *= 100;
    // output
    cout << "# Cache Simulation 1" << endl;
    cout << "Hit rate: " << hitRate << "%" << endl;
    cout << "Miss rate: " << missRate << "%" << endl;
    cout << "Total Trace Simulation Time: " << currTick << endl << endl;
}

void simulationTwo() { // 512 byte cache, 32 byte block, direct mapped
    
        
    unsigned x;
    stringstream ss;
    ifstream inFile;
    inFile.open("addresses.txt");
    string line, addy;
    bool initialize = false;
    string cache[3][16];    // 3x8 array
    int currTick = 0;
    double hitRate = 0;
    double missRate = 0;
    
    int numOfSets = 512 / 32;                   // 16
    int offsetBits = log2(32);                  // 5
    int indexBits = log2(numOfSets);            // 4
    int tagBits = 12 - offsetBits - indexBits;  // 3
    int lookupTime = ceil(log2(numOfSets)) * 1; // 1 way associativity
    int costOfCacheMiss = lookupTime + 100;
    int i, indexVal;
    
    // Set Bits
    cache[0][0] = "0000";
    cache[0][1] = "0001";
    cache[0][2] = "0010";
    cache[0][3] = "0011";
    cache[0][4] = "0100";
    cache[0][5] = "0101";
    cache[0][6] = "0110";
    cache[0][7] = "0111";
    cache[0][8] = "1000";
    cache[0][9] = "1001";
    cache[0][10] = "1010";
    cache[0][11] = "1011";
    cache[0][12] = "1100";
    cache[0][13] = "1101";
    cache[0][14] = "1110";
    cache[0][15] = "1111";
    
    // Valid Bits
    for (i = 0; i < numOfSets; i++){
        cache[1][i] = "0";
    }


    while(getline(inFile, line)) {
        //cout << "line: " << line << endl;// debug
        ss << hex << line;               // stores the hex value of line in ss
        ss >> x;                         // converts to decimal
        //cout << "decimal: " << x << endl;
        bitset<12> b(x);                  // converts to binary
        addy = b.to_string();
        //cout << "binary: " << addy << endl;   // ouputs binary of line
        
        string tag = addy.substr(0, 3);
        //cout << "tag: " << tag << endl;
        string index = addy.substr(3,4);
        //cout << "index: " << index << endl;
        string offset = addy.substr(7,5);
        //cout << "offset: " << offset << endl;
        
        // find set of address
        for (i = 0; i < numOfSets; i++){
            if (cache[0][i] == index) {
                //match = true;
                indexVal = i;       // finds the correct row for the set
                //cout << "indexVal: " << indexVal << endl;
                break;
            }
        }
        // *************************************************************************
        // Checks to see if cache tag is empty
        // Determines cache hit/miss
        // If miss, it fills the tag with the new value
        // *************************************************************************
        
        //cout << "Start Tick: " << currTick << endl;
        
        if (cache[1][indexVal] == "0") {      // if cache is empty
                                                    // should run a max of 8 times
            //cout << "cache tag is empty" << endl;   // debug
            cache[1][indexVal] = "1";
            cache[2][indexVal] = tag;
            currTick += costOfCacheMiss;
            missRate += 1;
        }
        else {                                      // if cache is NOT empty
            if (cache[2][indexVal] == tag) {  // if tags match
                //cout << "cache hit" << endl;        // debug
                currTick += 5;
                hitRate += 1;
            }
            else {
                //cout << "cache miss" << endl;       // debug
                cache[2][indexVal] = tag;
                currTick += costOfCacheMiss;
                missRate += 1;
            }
        }
        
        //cout << "End Tick: " << currTick << endl << endl;
        //cout << endl;
        ss.clear();
    }
    hitRate = hitRate / (hitRate + missRate);
    missRate = 1 - hitRate;
    hitRate *= 100;
    missRate *= 100;
    
    cout << "# Cache Simulation 2" << endl;
    cout << "Hit rate: " << hitRate << "%" << endl;
    cout << "Miss rate: " << missRate << "%" << endl;
    cout << "Total Trace Simulation Time: " << currTick << endl << endl;
}

void simulationThree() { // 256 byte cache, 64 byte block, direct mapped
    
        
    unsigned x;
    stringstream ss;
    ifstream inFile;
    inFile.open("addresses.txt");
    string line, addy;
    bool initialize = false;
    string cache[3][16];    // 3x8 array
    int currTick = 0;
    double hitRate = 0;
    double missRate = 0;
    
    int numOfSets = 256 / 64;                   // 4
    int offsetBits = log2(64);                  // 6
    int indexBits = log2(numOfSets);            // 2
    int tagBits = 12 - offsetBits - indexBits;  // 4
    int lookupTime = ceil(log2(numOfSets)) * 1; // 1 way associativity
    int costOfCacheMiss = lookupTime + 100;
    int i, indexVal;
    
    // Set Bits
    cache[0][0] = "00";
    cache[0][1] = "01";
    cache[0][2] = "10";
    cache[0][3] = "11";

    
    // Valid Bits
    for (i = 0; i < numOfSets; i++){
        cache[1][i] = "0";
    }


    while(getline(inFile, line)) {
        //cout << "line: " << line << endl;// debug
        ss << hex << line;               // stores the hex value of line in ss
        ss >> x;                         // converts to decimal
        //cout << "decimal: " << x << endl;
        bitset<12> b(x);                  // converts to binary
        addy = b.to_string();
        //cout << "binary: " << addy << endl;   // ouputs binary of line
        
        string tag = addy.substr(0, 4);
        //cout << "tag: " << tag << endl;
        string index = addy.substr(4,2);
        //cout << "index: " << index << endl;
        string offset = addy.substr(6,6);
        //cout << "offset: " << offset << endl;
        
        // find set of address
        for (i = 0; i < numOfSets; i++){
            if (cache[0][i] == index) {
                //match = true;
                indexVal = i;       // finds the correct row for the set
                //cout << "indexVal: " << indexVal << endl;
                break;
            }
        }
        // *************************************************************************
        // Checks to see if cache tag is empty
        // Determines cache hit/miss
        // If miss, it fills the tag with the new value
        // *************************************************************************
        
        //cout << "Start Tick: " << currTick << endl;
        
        if (cache[1][indexVal] == "0") {      // if cache is empty
                                                    // should run a max of 8 times
            //cout << "cache tag is empty" << endl;   // debug
            cache[1][indexVal] = "1";
            cache[2][indexVal] = tag;
            currTick += costOfCacheMiss;
            missRate += 1;
        }
        else {                                      // if cache is NOT empty
            if (cache[2][indexVal] == tag) {  // if tags match
                //cout << "cache hit" << endl;        // debug
                currTick += 5;
                hitRate += 1;
            }
            else {
                //cout << "cache miss" << endl;       // debug
                cache[2][indexVal] = tag;
                currTick += costOfCacheMiss;
                missRate += 1;
            }
        }
        
        //cout << "End Tick: " << currTick << endl << endl;
        //cout << endl;
        ss.clear();
    }
    hitRate = hitRate / (hitRate + missRate);
    missRate = 1 - hitRate;
    hitRate *= 100;
    missRate *= 100;
    
    cout << "# Cache Simulation 3" << endl;
    cout << "Hit rate: " << hitRate << "%" << endl;
    cout << "Miss rate: " << missRate << "%" << endl;
    cout << "Total Trace Simulation Time: " << currTick << endl << endl;
}

void simulationFour() { // 256 byte cache, 32 byte block, 4-way
    
        
    unsigned x;
    stringstream ss;
    ifstream inFile;
    inFile.open("addresses.txt");
    string line, addy;
    bool initialize = false;
    string cache[5][8];    // 5x8 array
    int currTick = 0;
    double hitRate = 0;
    double missRate = 0;
    
    int numOfSets = 256 / 32;   // 8
    int offsetBits = log2(32);                  // 5
    int indexBits = log2(numOfSets);            // 3
    int tagBits = 12 - offsetBits - indexBits;  // 4
    int lookupTime = ceil(log2(numOfSets)) * 4; // 1 way associativity
    int costOfCacheMiss = lookupTime + 100;
    int i, indexVal;
    // For LRU eviction
    // Values are for ordered block eviction
    int block1Tick = 1; 
    int block2Tick = 2; 
    int block3Tick = 3; 
    int block4Tick = 4;
    
    // Set bits
    cache[0][0] = "000";
    cache[0][1] = "001";
    cache[0][2] = "010";
    cache[0][3] = "011";
    cache[0][4] = "100";
    cache[0][5] = "101";
    cache[0][6] = "110";
    cache[0][7] = "111";

    while(getline(inFile, line)) {
        //cout << "line: " << line << endl;// debug
        ss << hex << line;               // stores the hex value of line in ss
        ss >> x;                         // converts to decimal
        //cout << "decimal: " << x << endl;
        bitset<12> b(x);                  // converts to binary
        addy = b.to_string();
        //cout << "binary: " << addy << endl;   // ouputs binary of line
        
        string tag = addy.substr(0, 4);
        //cout << "tag: " << tag << endl;
        string index = addy.substr(4,3);
        //cout << "index: " << index << endl;
        string offset = addy.substr(7,5);
        //cout << "offset: " << offset << endl;
        
        // find set of address
        for (i = 0; i < numOfSets; i++){
            if (cache[0][i] == index) {
                //match = true;
                indexVal = i;       // finds the correct row for the set
                //cout << "indexVal: " << indexVal << endl;
                break;
            }
        }
        
        // *************************************************************************
        // Checks to see if cache tag is empty
        // Determines cache hit/miss
        // If miss, it fills the tag with the new value
        // *************************************************************************
        
        if (cache[1][indexVal] == tag) {        // hit on block 1
            currTick += 5;
            hitRate += 1;
        }
        else if (cache[2][indexVal] == tag) {   // hit on block 2
            currTick += 5;
            hitRate += 1;
        }
        else if (cache[3][indexVal] == tag) {   // hit on block 3
            currTick += 5;
            hitRate += 1;
        }
        else if (cache[4][indexVal] == tag) {   // hit on block 4
            currTick += 5;
            hitRate += 1;
        }
        else {                                  // cache miss
            // if block1Tick is the oldest
            if (block1Tick == min({block1Tick, block2Tick, block3Tick, block4Tick})){
                cache[1][indexVal] = tag;
                // update tick values
                currTick += costOfCacheMiss;
                block1Tick = currTick;
                // calculate missRate
                missRate += 1;
            }
            else if (block2Tick == min({block1Tick, block2Tick, block3Tick, block4Tick})){
                cache[2][indexVal] = tag;
                // update tick values
                currTick += costOfCacheMiss;
                block2Tick = currTick;
                // calculate missRate
                missRate += 1;
            }
            else if (block3Tick == min({block1Tick, block2Tick, block3Tick, block4Tick})){
                cache[3][indexVal] = tag;
                // update tick values
                currTick += costOfCacheMiss;
                block3Tick = currTick;
                // calculate missRate
                missRate += 1;
            }
            else if (block4Tick == min({block1Tick, block2Tick, block3Tick, block4Tick})){
                cache[4][indexVal] = tag;
                // update tick values
                currTick += costOfCacheMiss;
                block4Tick = currTick;
                // calculate missRate
                missRate += 1;
            }
            else {
                cout << "ERROR: 4-WAY TAG MISMATCH" << endl;
            }

        }
        //cout << "End Tick: " << currTick << endl << endl;
        //cout << endl;
        ss.clear();
    }
    hitRate = hitRate / (hitRate + missRate);
    missRate = 1 - hitRate;
    hitRate *= 100;
    missRate *= 100;
    
    cout << "# Cache Simulation 4" << endl;
    cout << "Hit rate: " << hitRate << "%" << endl;
    cout << "Miss rate: " << missRate << "%" << endl;
    cout << "Total Trace Simulation Time: " << currTick << endl << endl;
}

int main() {
    
    simulationOne();
    simulationTwo();
    simulationThree();
    simulationFour();
    
    return 0;
}

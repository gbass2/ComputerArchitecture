#include <iostream>
#include <sstream>
#include <string>
#include <fstream>
#include <bitset>
#include <math.h>
using namespace std;

void simulationOne() { // 256 byte cache, 32 byte block, direct mapped
    
        
    unsigned x;
    stringstream ss;
    ifstream inFile;
    inFile.open("addresses.txt");
    string line, addy;
    bool initialize = false;
    string cache[3][8];    // 3x8 array
    int currTick = 0;
    double hitRate = 0;
    double missRate = 0;
    
    int numOfSets = 256 / 32;   // 8
    int offsetBits = log2(32);                  // 5
    int indexBits = log2(numOfSets);            // 3
    int tagBits = 12 - offsetBits - indexBits;  // 4
    int lookupTime = ceil(log2(numOfSets)) * 1; // 1 way associativity
    int costOfCacheMiss = lookupTime + 100;
    int i, indexVal;
    // initialize index bits (3 bits so we go from 0-7)
    /* There is a better way todo this! I'll implement it if we have time */
    cache[0][0] = "000";
    cache[0][1] = "001";
    cache[0][2] = "010";
    cache[0][3] = "011";
    cache[0][4] = "100";
    cache[0][5] = "101";
    cache[0][6] = "110";
    cache[0][7] = "111";
    
    // initializes the valid column with 0
    for (i = 0; i < numOfSets; i++){
        cache[1][i] = "0";
    }


    while(getline(inFile, line)) {
        //cout << "line: " << line << endl;// debug
        ss << hex << line;               // stores the hex value of line in ss
        ss >> x;                         // converts to decimal
        //cout << "decimal: " << x << endl;
        bitset<12> b(x);                  // converts to binary
        addy = b.to_string();
        //cout << "binary: " << addy << endl;   // ouputs binary of line
        
        string tag = addy.substr(0, 4);
        //cout << "tag: " << tag << endl;
        string index = addy.substr(4,3);
        //cout << "index: " << index << endl;
        string offset = addy.substr(7,5);
        //cout << "offset: " << offset << endl;
        
        // find set of address
        for (i = 0; i < numOfSets; i++){
            if (cache[0][i] == index) {
                //match = true;
                indexVal = i;       // finds the correct row for the set
                //cout << "indexVal: " << indexVal << endl;
                break;
            }
        }
        // *************************************************************************
        // Checks to see if cache tag is empty
        // Determines cache hit/miss
        // If miss, it fills the tag with the new value
        // *************************************************************************
        
        //cout << "Start Tick: " << currTick << endl;
        
        if (cache[1][indexVal] == "0") {      // if cache is empty
                                                    // should run a max of 8 times
            //cout << "cache tag is empty" << endl;   // debug
            cache[1][indexVal] = "1";
            cache[2][indexVal] = tag;
            currTick += costOfCacheMiss;
            missRate += 1;
        }
        else {                                      // if cache is NOT empty
            if (cache[2][indexVal] == tag) {  // if tags match
                //cout << "cache hit" << endl;        // debug
                currTick += 5;
                hitRate += 1;
            }
            else {
                //cout << "cache miss" << endl;       // debug
                cache[2][indexVal] = tag;
                currTick += costOfCacheMiss;
                missRate += 1;
            }
        }
        
        //cout << "End Tick: " << currTick << endl << endl;
        //cout << endl;
        ss.clear();
    }
    hitRate = hitRate / (hitRate + missRate);
    missRate = 1 - hitRate;
    hitRate *= 100;
    missRate *= 100;
    
    cout << "# Cache Simulation 1" << endl;
    cout << "Hit rate: " << hitRate << "%" << endl;
    cout << "Miss rate: " << missRate << "%" << endl;
    cout << "Total Trace Simulation Time: " << currTick << endl << endl;
}

void simulationTwo() { // 256 byte cache, 32 byte block, direct mapped
    
        
    unsigned x;
    stringstream ss;
    ifstream inFile;
    inFile.open("addresses.txt");
    string line, addy;
    bool initialize = false;
    string cache[3][16];    // 3x8 array
    int currTick = 0;
    double hitRate = 0;
    double missRate = 0;
    
    int numOfSets = 512 / 32;                   // 16
    int offsetBits = log2(32);                  // 5
    int indexBits = log2(numOfSets);            // 4
    int tagBits = 12 - offsetBits - indexBits;  // 3
    int lookupTime = ceil(log2(numOfSets)) * 1; // 1 way associativity
    int costOfCacheMiss = lookupTime + 100;
    int i, indexVal;
    
    // Set Bits
    cache[0][0] = "0000";
    cache[0][1] = "0001";
    cache[0][2] = "0010";
    cache[0][3] = "0011";
    cache[0][4] = "0100";
    cache[0][5] = "0101";
    cache[0][6] = "0110";
    cache[0][7] = "0111";
    cache[0][8] = "1000";
    cache[0][9] = "1001";
    cache[0][10] = "1010";
    cache[0][11] = "1011";
    cache[0][12] = "1100";
    cache[0][13] = "1101";
    cache[0][14] = "1110";
    cache[0][15] = "1111";
    
    // Valid Bits
    for (i = 0; i < numOfSets; i++){
        cache[1][i] = "0";
    }


    while(getline(inFile, line)) {
        //cout << "line: " << line << endl;// debug
        ss << hex << line;               // stores the hex value of line in ss
        ss >> x;                         // converts to decimal
        //cout << "decimal: " << x << endl;
        bitset<12> b(x);                  // converts to binary
        addy = b.to_string();
        //cout << "binary: " << addy << endl;   // ouputs binary of line
        
        string tag = addy.substr(0, 3);
        //cout << "tag: " << tag << endl;
        string index = addy.substr(3,4);
        //cout << "index: " << index << endl;
        string offset = addy.substr(7,5);
        //cout << "offset: " << offset << endl;
        
        // find set of address
        for (i = 0; i < numOfSets; i++){
            if (cache[0][i] == index) {
                //match = true;
                indexVal = i;       // finds the correct row for the set
                //cout << "indexVal: " << indexVal << endl;
                break;
            }
        }
        // *************************************************************************
        // Checks to see if cache tag is empty
        // Determines cache hit/miss
        // If miss, it fills the tag with the new value
        // *************************************************************************
        
        //cout << "Start Tick: " << currTick << endl;
        
        if (cache[1][indexVal] == "0") {      // if cache is empty
                                                    // should run a max of 8 times
            //cout << "cache tag is empty" << endl;   // debug
            cache[1][indexVal] = "1";
            cache[2][indexVal] = tag;
            currTick += costOfCacheMiss;
            missRate += 1;
        }
        else {                                      // if cache is NOT empty
            if (cache[2][indexVal] == tag) {  // if tags match
                //cout << "cache hit" << endl;        // debug
                currTick += 5;
                hitRate += 1;
            }
            else {
                //cout << "cache miss" << endl;       // debug
                cache[2][indexVal] = tag;
                currTick += costOfCacheMiss;
                missRate += 1;
            }
        }
        
        //cout << "End Tick: " << currTick << endl << endl;
        //cout << endl;
        ss.clear();
    }
    hitRate = hitRate / (hitRate + missRate);
    missRate = 1 - hitRate;
    hitRate *= 100;
    missRate *= 100;
    
    cout << "# Cache Simulation 2" << endl;
    cout << "Hit rate: " << hitRate << "%" << endl;
    cout << "Miss rate: " << missRate << "%" << endl;
    cout << "Total Trace Simulation Time: " << currTick << endl << endl;
}

void simulationThree() { // 256 byte cache, 32 byte block, direct mapped
    
        
    unsigned x;
    stringstream ss;
    ifstream inFile;
    inFile.open("addresses.txt");
    string line, addy;
    bool initialize = false;
    string cache[3][16];    // 3x8 array
    int currTick = 0;
    double hitRate = 0;
    double missRate = 0;
    
    int numOfSets = 256 / 64;                   // 4
    int offsetBits = log2(64);                  // 6
    int indexBits = log2(numOfSets);            // 2
    int tagBits = 12 - offsetBits - indexBits;  // 4
    int lookupTime = ceil(log2(numOfSets)) * 1; // 1 way associativity
    int costOfCacheMiss = lookupTime + 100;
    int i, indexVal;
    
    // Set Bits
    cache[0][0] = "00";
    cache[0][1] = "01";
    cache[0][2] = "10";
    cache[0][3] = "11";

    
    // Valid Bits
    for (i = 0; i < numOfSets; i++){
        cache[1][i] = "0";
    }


    while(getline(inFile, line)) {
        //cout << "line: " << line << endl;// debug
        ss << hex << line;               // stores the hex value of line in ss
        ss >> x;                         // converts to decimal
        //cout << "decimal: " << x << endl;
        bitset<12> b(x);                  // converts to binary
        addy = b.to_string();
        //cout << "binary: " << addy << endl;   // ouputs binary of line
        
        string tag = addy.substr(0, 4);
        //cout << "tag: " << tag << endl;
        string index = addy.substr(4,2);
        //cout << "index: " << index << endl;
        string offset = addy.substr(6,6);
        //cout << "offset: " << offset << endl;
        
        // find set of address
        for (i = 0; i < numOfSets; i++){
            if (cache[0][i] == index) {
                //match = true;
                indexVal = i;       // finds the correct row for the set
                //cout << "indexVal: " << indexVal << endl;
                break;
            }
        }
        // *************************************************************************
        // Checks to see if cache tag is empty
        // Determines cache hit/miss
        // If miss, it fills the tag with the new value
        // *************************************************************************
        
        //cout << "Start Tick: " << currTick << endl;
        
        if (cache[1][indexVal] == "0") {      // if cache is empty
                                                    // should run a max of 8 times
            //cout << "cache tag is empty" << endl;   // debug
            cache[1][indexVal] = "1";
            cache[2][indexVal] = tag;
            currTick += costOfCacheMiss;
            missRate += 1;
        }
        else {                                      // if cache is NOT empty
            if (cache[2][indexVal] == tag) {  // if tags match
                //cout << "cache hit" << endl;        // debug
                currTick += 5;
                hitRate += 1;
            }
            else {
                //cout << "cache miss" << endl;       // debug
                cache[2][indexVal] = tag;
                currTick += costOfCacheMiss;
                missRate += 1;
            }
        }
        
        //cout << "End Tick: " << currTick << endl << endl;
        //cout << endl;
        ss.clear();
    }
    hitRate = hitRate / (hitRate + missRate);
    missRate = 1 - hitRate;
    hitRate *= 100;
    missRate *= 100;
    
    cout << "# Cache Simulation 3" << endl;
    cout << "Hit rate: " << hitRate << "%" << endl;
    cout << "Miss rate: " << missRate << "%" << endl;
    cout << "Total Trace Simulation Time: " << currTick << endl << endl;
}

int main() {
    
    simulationOne();
    simulationTwo();
    simulationThree();
    return 0;
}
